@code{

  /*TODO: some methods lack necessary type infos for scala*/
  def skipMethod(method) {
    return method.name == 'addInterceptor' || method.name == 'removeInterceptor';
  }

  def findBasicMethods(methods) {
    var ret = new java.util.ArrayList();
    for(method : methods) {
      if(!method.isFluent() && !method.isCacheReturn && !method.isStaticMethod && !method.isDefaultMethod && !skipMethod(method))
        ret.add(method);
    }
    return ret;
  }

  def findDefaultMethods(methods) {
    var ret = new java.util.ArrayList();
    for(method : methods) {
      if(method.isDefaultMethod && !skipMethod(method))
        ret.add(method);
    }
    return ret;
  }

  def findFluentMethods(methods) {
    var ret = new java.util.ArrayList();
    for(method : methods) {
      if(method.isFluent && !skipMethod(method))
        ret.add(method);
    }
    return ret;
  }

  def findCacheReturnMethods(methods) {
    var ret = new java.util.ArrayList();
    for(method : methods) {
      if(method.isCacheReturn && !skipMethod(method))
        ret.add(method);
    }
    return ret;
  }

  def findFutureMethods(methods) {
    var ret = new java.util.ArrayList();
    for(method : methods) {
      if(!method.isFluent() && shouldMethodReturnAFuture(method) && !skipMethod(method))
        ret.add(method);
    }
    return ret;
  }

  def isLastParamAHandlerWithAsyncResult(method) {
    var size = method.params.size;
    return method.params[size-1].type.kind == CLASS_HANDLER && method.params[size-1].type.args[0].kind == CLASS_ASYNC_RESULT;
  }

  def isMethodNeedsOverride(callingClassName, method) {
    if (method.ownerTypes.size() > 1)
      return true;
    else {
      /*There is only one entry in here (0 would be a bug)*/
      for(ownerType : method.ownerTypes) {
        if(ownerType.name != callingClassName)
          return true;
      }
    }
    return false;
  }

  def shouldMethodReturnAFuture(method) {
    var size = method.params.size;
    return size > 0 && isLastParamAHandlerWithAsyncResult(method) && !(method.returnType.kind == CLASS_HANDLER);
  }

  def invokeMethod(target, type, method, typeParams) {
    return toScalaWithConversion(invokeMethodWithoutConvertingReturn(target, type, method, typeParams), method.returnType, typeParams, method.typeParams);
  }

  def invokeMethodWithoutConvertingReturn(target, type, method, typeParams) {
    var typeParamString = '';
    if(!method.typeParams.isEmpty){
      for(typeParam : method.typeParams) {
        if (typeParamString != '')
          typeParamString += ',';
        typeParamString += typeParam.name;
      }
      typeParamString = '[' + typeParamString + ']';
    }

    var paramString = '';
    for(param : method.params) {
      if (paramString != '')
        paramString += ',';
      paramString += toJavaWithConversion(escapeIfKeyword(param.name), param.type, typeParams, method.typeParams);
    }

    return target + '.' + escapeIfKeyword(method.name) + typeParamString + '(' + paramString + ')';
  }

  def invokeStaticMethod(target, type, method) {
    /*class level typeparams aren't needed for static methods*/
    var typeParams = java.util.Collections.emptyList();

    var paramString = '';
    for(param : method.params) {
      if (paramString != '')
        paramString += ',';
      paramString += toJavaWithConversion(escapeIfKeyword(param.name), param.type, typeParams, method.typeParams);
    }

    var typeParamString = '';
    if(!method.typeParams.isEmpty){
      for(typeParam : method.typeParams) {
        if (typeParamString != '')
          typeParamString += ',';
        typeParamString += typeParam.name;
      }
      typeParamString = '[' + typeParamString + ']';
    }
    return toScalaWithConversion(target + '.' + escapeIfKeyword(method.name) + typeParamString + '(' + paramString + ')', method.returnType, typeParams, method.typeParams);
  }

}
