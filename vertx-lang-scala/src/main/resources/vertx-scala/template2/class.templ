@comment{"# Template for DataObject code generation"}

@comment{"# Defines a few helper functions"}
@includeNamed{'scala-doc.templ'}
@includeNamed{'scala-imports.templ'}
@includeNamed{'scala-types.templ'}
@includeNamed{'scala-methods.templ'}
@code{
  var className = helper.getSimpleName(type.name);
}
/*\n
 * Copyright 2014 Red Hat, Inc.\n
 *\n
 * Red Hat licenses this file to you under the Apache License, version 2.0\n
 * (the "License"); you may not use this file except in compliance with the\n
 * License.  You may obtain a copy of the License at:\n
 *\n
 * http://www.apache.org/licenses/LICENSE-2.0\n
 *\n
 * Unless required by applicable law or agreed to in writing, software\n
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n
 * License for the specific language governing permissions and limitations\n
 * under the License.\n
 */\n\n

package @{type.raw.translatePackageName("scala")}\n
\n
import scala.compat.java8.FunctionConverters._\n
import io.vertx.lang.scala.HandlerOps._\n
import io.vertx.lang.scala.Converter._\n
@comment{"# Generate the imports"}
@foreach{importedType : generateImports(type, importedTypes, methods)}
import @{importedType}\n
@end{}
\n

@if{doc != null}
/**\n
@{renderDoc("  *", doc, renderDocLink)}
  */\n
@end{}
@if{concrete}
	class @{className}@{assembleTypeParams(typeParams)}(private val _asJava: Object, private val _useTypeTags:Boolean = false)
@else{}
	trait @{className}@{assembleTypeParams(typeParams)}
@end{}

@comment{"## Inheritance"}
@if{!superTypes.isEmpty}
	 \n    extends @foreach{superType : superTypes}@{toScalaType(superType);}@if{superType.raw.isConcrete()}(_asJava)@end{}@end{' \n    with '}
@else{type.isHandler}
	 \n    extends io.vertx.core.Handler[@{toScalaType(type.getHandlerArg);}]
@end{}
 {\n
\n

@if{concrete}
	@includeNamed{'class-body.templ'}
	\n
  object @{className}{\n
    def apply@{assembleTypeParams(typeParams)}(asJava: Object, useTypeTags:Boolean = false) = new @{className}@{assembleTypeParams(typeParams)}(asJava, useTypeTags)
  \n
  //static methods\n
	@foreach{method : staticMethods}
    def @{escapeIfKeyword(method.name)}
	@if{!method.typeParams.isEmpty}
	[@foreach{typeParam : method.typeParams}@{typeParam.name}@end{', '}]
	@end{}
	(
		@foreach{param:method.params}
			@{escapeIfKeyword(param.name)}: @{toScalaType(param.type)}
		@end{','}):@{toScalaType(method.returnType)} = {\n
      @{invokeStaticMethod('J'+className, type, method)}\n
    }\n
	\n
	@end{}
  }\n
@else{}
	@includeNamed{'trait-body.templ'}
	\n
  object @{className}{\n
    def apply@{assembleTypeParams(typeParams)}(asJava: Object, useTypeTags:Boolean = false):@{className}@{assembleTypeParams(typeParams)} = new @{className}Impl@{assembleTypeParams(typeParams)}(asJava, useTypeTags)
    \n
      private class @{className}Impl@{assembleTypeParams(typeParams)}(private val _asJava: Object, private val _useTypeTags:Boolean) extends @{className}@{assembleTypeParams(typeParams)} {\n\n
      @includeNamed{'class-body.templ'}
  }\n
@end{}






