@code{
  def toScalaWithConversion(name, type, typeParams, methodTypeParams) {
    var nullable = type.isNullable;
    /*TODO: Bug, some types get returned as CLASS_OTHER instead of CLASS_VOID*/
    if (type.kind.basic) {
      if(nullable) {
        return 'scala.Option(' + name + ')';
      }
      else {
        return name;
      }
    } else if (type.kind == CLASS_THROWABLE) {
      return name;
    } else if (type.kind == CLASS_OBJECT) {
      if(nullable) {
        return 'scala.Option(' + name + ')';
      }
      else {
        return name;
      }
    } else if (type.kind == CLASS_VOID || type.name == 'java.lang.Void' || type.name == 'void') {
      return name;
    }
    else if (type.kind == CLASS_JSON_OBJECT || type.kind == CLASS_JSON_ARRAY || type.kind == CLASS_ENUM) {
      if(nullable) {
        return 'scala.Option(' + name + ')';
      }
      else {
        return name;
      }
    } else if (type.kind == CLASS_DATA_OBJECT) {
      if(nullable) {
        return 'scala.Option(' + name + ').map(' + type.simpleName + '(_))';
      }
      else {
        return type.simpleName + '(' + name + ')';
      }
    } else if (type.kind == CLASS_API) {
      var args = '';
      if(type.isParameterized()) {
        for(arg : type.args) {
          if(args != '') {
            args += ',';
          }
          args += toScalaType(arg);
        }
        if (args != '')
          args = '[' + args + ']';
      }
      if(nullable) {
        return 'scala.Option(' + name + ').map(' + helper.getNonGenericType(type.simpleName) + args + '(_))';
      }
      else {
        return helper.getNonGenericType(type.simpleName) + args + '(' + name + ')';
      }
    } else if (type.kind == CLASS_HANDLER) {
      return '{x: ' + toScalaType(type.args[0], typeParams, methodTypeParams) + ' => ' + name + '.handle(' + toJavaWithConversion('x', type.args[0], typeParams, methodTypeParams) + ')}';
    } else if (type.kind == CLASS_ASYNC_RESULT) {
      return 'AsyncResultWrapper[' + toJavaType(type.args[0]) + ',' + toScalaType(type.args[0]) + '](x, a => ' + toScalaWithConversion('a', type.args[0], typeParams, methodTypeParams) + ')';
    } else if (type.kind.collection) {
      if (type.kind == CLASS_LIST){
        if(nullable) {
          return 'scala.Option(' + name + ').map(_.asScala.map(x => '+ toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) +'))';
        }
        else {
          return name + '.asScala.map(x => '+ toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) +')';
        }
      } else if (type.kind == CLASS_SET){
        if(nullable) {
          return 'scala.Option(' + name + ').map(_.asScala.map(x => '+ toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) +'))';
        }
        else {
          return name + '.asScala.map(x => '+ toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) +')';
        }
      } else if (type.kind == CLASS_MAP){
        if(nullable) {
          return 'scala.Option(' + name + ').map(_.asScala.mapValues(x => '+ toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) +'))';
        }
        else {
          return name + '.asScala.mapValues(x => '+ toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) +')';
        }
      }
    }
    else {
      return 'WTF!!!!!!'+type.name+' '+type.kind;
    }
  }

  def ifNullableCobvertWithOption(type, expr, typeParams, methodTypeParams) {
    if(type.isNullable) {
      return 'scala.Option('+expr').map(x => ' + toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) + ')';
    }
    else {
      return expr ;
    }
  }

  def toJavaWithConversion(name, type, typeParams, methodTypeParams) {
    var nullable = type.isNullable;
    /*TODO: Bug, some types get returned as CLASS_OTHER instead of CLASS_VOID*/
    if (type.kind.basic) {
      var ret = name;
      if(nullable)
        ret = name + '.map(x => x).getOrElse(null)';
      return ret;
    } else if (type.kind == CLASS_THROWABLE) {
      var ret = name;
      if(nullable)
        ret = name + '.map(x => x).getOrElse(null)';
      return ret;
    } else if (type.kind == CLASS_OBJECT) {
      var ret = name;
      if(nullable)
        ret = name + '.map(x => x).getOrElse(null)';
      return ret;
    } else if (type.kind == CLASS_VOID || type.name == 'java.lang.Void' || type.name == 'void') {
      return name;
    }
    else if (type.kind == CLASS_JSON_OBJECT || type.kind == CLASS_JSON_ARRAY || type.kind == CLASS_ENUM) {
      var ret = name;
      if(nullable)
        ret = name + '.map(x => x).getOrElse(null)';
      return ret;
    } else if (type.kind == CLASS_DATA_OBJECT) {
      var ret = name + '.asJava';
      if(nullable)
        ret = name + '.map(' + name +' => ' + ret + ').getOrElse(null)';
      return ret;
    } else if (type.kind == CLASS_API) {
      var ret = name + '.asJava' + fromObjectToInstanceOf(type, typeParams, methodTypeParams);
      if(nullable)
        ret = name + '.map(' + name +' => ' + ret + ').getOrElse(null)';
      return ret;
    } else if (type.kind == CLASS_HANDLER) {
      var ret = '{x: ' + toJavaType(type.args[0], typeParams, methodTypeParams) + ' => ' + name + '.handle(' + toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams) + ')}';
      return ret;
    } else if (type.kind == CLASS_ASYNC_RESULT) {
      var ret = 'AsyncResultWrapper[' + toScalaType(type.args[0]) + ',' + toJavaType(type.args[0]) + '](x, a => ' + toJavaWithConversion('a', type.args[0], typeParams, methodTypeParams) + ')';
      if(nullable)
        ret = name + '.map(' + name +' => ' + ret + ').getOrElse(null)';
      return ret;
    } else if (type.kind.collection) {
      var ret = name;
      if (type.kind == CLASS_LIST){
        ret += '.map(x => '+ toJavaWithConversion('x', type.args[0], typeParams, methodTypeParams) +')';
      } else if (type.kind == CLASS_SET){
        ret += '.map(x => '+ toJavaWithConversion('x', type.args[0], typeParams, methodTypeParams) +')';
      } else if (type.kind == CLASS_MAP){
        ret += '.mapValues(x => '+ toJavaWithConversion('x', type.args[0], typeParams, methodTypeParams) +')';
      }
      ret += '.asJava';
      if(nullable)
        ret = name + '.map(' + name +' => ' + ret + ').getOrElse(null)';
      return ret;
    } else if(type.kind == CLASS_ASYNC_RESULT) {
      var ret = 'AsyncResultWrapper('+name+')';
      if(nullable)
        ret = name + '.map(' + name +' => ' + ret + ').getOrElse(null)';
      return ret;
    }
    else if(type.kind == CLASS_FUNCTION) {
      var executed = name + "(" +toScalaWithConversion('x', type.args[0], typeParams, methodTypeParams)+ ")";
      executed = toJavaWithConversion(executed, type.args[1], typeParams, methodTypeParams);
      var ret = "{x:" + toJavaType(type.args[0]) + "=> " + executed + "}";
      if(nullable)
        ret = name + '.map(' + name +' => ' + ret + ').getOrElse(null)';
      return ret;
    }
    else {
      return 'WTF!!!!!!'+type.name+' '+type.kind;
    }
  }

  def toJavaType(type) {
    var nullable = type.isNullable;
    /*TODO: Bug, some types get returned as CLASS_OTHER instead of CLASS_VOID*/
    if (type.kind.basic) {
      return type.name;
    } else if (type.kind == CLASS_THROWABLE) {
      return type.simpleName;
    } else if (type.kind == CLASS_OBJECT) {
      return type.simpleName;
    } else if (type.kind == CLASS_VOID || type.name == 'java.lang.Void' || type.name == 'void') {
      return type.simpleName;
    }
    else if (type.kind == CLASS_JSON_OBJECT || type.kind == CLASS_JSON_ARRAY || type.kind == CLASS_ENUM) {
      return type.simpleName;
    } else if (type.kind == CLASS_DATA_OBJECT) {
      return 'J' + type.simpleName;
    } else if (type.kind == CLASS_API) {
      var ret = 'J' + helper.getNonGenericType(type.simpleName);
      if(type.isParameterized()) {
        var args = '';
        for(arg : type.args) {
          if(args != '') {
            args += ',';
          }
          args += toJavaType(arg);
        }
        ret += '[' + args + ']';
      } else if(!type.raw.params.isEmpty) {
        var args = '';
        for(arg : type.raw.params) {
          if(args != '') {
            args += ',';
          }
          args += arg.name;
        }
        ret += '[' + args + ']';
      }
      return ret;
    } else if (type.kind == CLASS_HANDLER) {
      return 'Handler['+ toJavaType(type.args[0]) +']';
    } else if (type.kind.collection) {
      var ret = '';
      if (type.kind == CLASS_LIST){
        ret += 'java.util.List['+ toJavaType(type.args[0]) +']';
      } else if (type.kind == CLASS_SET){
        ret += 'java.util.Set['+ toJavaType(type.args[0]) +']';
      } else if (type.kind == CLASS_MAP){
        ret += 'java.util.Map[String, '+ toJavaType(type.args[0]) +']';
      }
      return ret;
    } else if(type.kind == CLASS_ASYNC_RESULT) {
      return helper.getNonGenericType(type.simpleName) + '['+ toJavaType(type.args[0]) +']';
    }
    else {
      return 'WTF!!!!!!'+type.name+' '+type.kind;
    }
  }

  def toScalaType(type) {
    var nullable = type.isNullable;
    /*TODO: Bug, some types get returned as CLASS_OTHER instead of CLASS_VOID*/
    if (type.kind == CLASS_VOID || type.name == 'java.lang.Void' || type.name == 'void') {
      return 'Unit';
    } else if (type.kind == CLASS_OBJECT) {
      if(type.name.contains('Object')){
        return wrapInOptionIfNullable(nullable, 'AnyRef')
      }
      else {
        return wrapInOptionIfNullable(nullable, type.name);
      }
    } else if (type.kind == CLASS_THROWABLE) {
      return 'Throwable';
    } else if (type.kind.basic) {
      if (type.name == 'byte' || type.name == 'java.lang.Byte') {
        return wrapInOptionIfNullable(nullable, 'Byte');
      } else if (type.name == 'short' || type.name == 'java.lang.Short') {
        return wrapInOptionIfNullable(nullable, 'Short');
      } else if (type.name == 'int' || type.name == 'java.lang.Integer') {
        return wrapInOptionIfNullable(nullable, 'Int');
      } else if (type.name == 'long' || type.name == 'java.lang.Long') {
        return wrapInOptionIfNullable(nullable, 'Long');
      } else if (type.name == 'float' || type.name == 'java.lang.Float') {
        return wrapInOptionIfNullable(nullable, 'Float');
      } else if (type.name == 'double' || type.name == 'java.lang.Double') {
        return wrapInOptionIfNullable(nullable, 'Double');
      } else if (type.name == 'boolean' || type.name == 'java.lang.Boolean') {
        return wrapInOptionIfNullable(nullable, 'Boolean');
      } else if (type.name == 'char' || type.name == 'java.lang.Character') {
        return wrapInOptionIfNullable(nullable, 'Char');
      } else if (type.kind == CLASS_STRING) {
        return wrapInOptionIfNullable(nullable, 'String');
      }
    } else if (type.kind == CLASS_DATA_OBJECT) {
      return wrapInOptionIfNullable(nullable, type.simpleName);
    } else if (type.kind == CLASS_LIST){
        var ret = 'scala.collection.mutable.Buffer';
        if (!type.args.isEmpty)
          ret += '[' + toScalaType(type.args[0]) + ']';
        return wrapInOptionIfNullable(nullable, ret);
    } else if (type.kind == CLASS_SET){
        var ret = 'scala.collection.mutable.Set';
        if (!type.args.isEmpty)
          ret += '[' + toScalaType(type.args[0]) + ']';
        return wrapInOptionIfNullable(nullable, ret);
    } else if (type.kind == CLASS_MAP){
        var ret = 'Map';
        if (!type.args.isEmpty())
          ret = 'Map[' + toScalaType(type.args[0]) + ', ' + toScalaType(type.args[1]) + ']';
        return wrapInOptionIfNullable(nullable, ret);
    } else if (type.kind == CLASS_HANDLER) {
      return "Handler[" + toScalaType(type.args[0]) + "]";
    } else if (type.kind == CLASS_FUNCTION) {
      var type1 = toScalaType(type.args[0]);
      var type2 = toScalaType(type.args[1]);

      var ret = "";
      if (type1.equals("Unit")) {
        ret = "() => "+type2;
      } else {
        ret = type1 + " => " + type2;
      }
      return wrapInOptionIfNullable(nullable, ret);
    } else if (type.kind == CLASS_JSON_OBJECT ||
               type.kind == CLASS_JSON_ARRAY ||
               type.kind == CLASS_ENUM){
      return wrapInOptionIfNullable(nullable, type.name);
    } else if (type.kind == CLASS_ASYNC_RESULT) {
      var ret = 'AsyncResult';
      if(!type.args.isEmpty)
        ret += '[' + toScalaType(type.args[0]) + ']';
      else
        ret += '[_]';
      return wrapInOptionIfNullable(nullable, ret);
    } else if (type.kind == CLASS_API) {
      var ret = helper.getNonGenericType(type.simpleName);
      if (type instanceof io.vertx.codegen.type.ParameterizedTypeInfo) {
        if(type.args.empty) {
          ret += '[_]';
        }
        else {
          ret += '[';
          var first = true;
          for (arg : type.args) {
            if (first) {
              first = false;
            } else {
              ret += ', ';
            }
            ret += toScalaType(arg);
          }
          ret += ']';
        }
      }
      else if(type.name.contains('io.vertx.core.Future')) {
        ret += '[_]';
      }
      return wrapInOptionIfNullable(nullable, ret);
    }
    else {
      return 'WTF!!!!!!'+type.name+' '+type.kind;
    }
  }

  def wrapInOptionIfNullable(nullable, expression) {
    if(nullable) {
      return 'scala.Option[' + expression + ']';
    }
    return expression;
  }

  def fromPropertyInfoToScalaTypeWithConversion(name, info) {
    var typeParams = new java.util.ArrayList();
    var methodTypeParams = new java.util.ArrayList();
    if (info.kind.isValue){
      return toScalaWithConversion(name, info.type, typeParams, methodTypeParams);
    } else if (info.kind.isList){
      return name + '.asScala.map(x => '+ toScalaWithConversion('x', info.type, typeParams, methodTypeParams) +')';
    } else if (info.kind.isSet){
      return name + '.asScala.map(x => '+ toScalaWithConversion('x', info.type, typeParams, methodTypeParams) +')';
    } else if (info.kind.isMap){
      return name + '.asScala.mapValues(x => '+ toScalaWithConversion('x', info.type, typeParams, methodTypeParams) +')';
    }
    return "UNKOWN PROPERTY TYPE";
  }


  def fromPropertyInfoToScala(info) {
    if (info.kind.isValue){
      return toScalaType(info.type);
    }else if (info.kind.isList){
      var ret = 'scala.collection.mutable.Buffer';
      ret += '[' + toScalaType(info.type) + ']';
      return ret;
    } else if (info.kind.isSet){
      var ret = 'scala.collection.mutable.Set';
      ret += '[' + toScalaType(info.type) + ']';
      return ret;
    } else if (info.kind.isMap){
      var ret = 'Map';
      ret = 'Map[String, ' + toScalaType(info.type) + ']';
      return ret;
    }
    return "UNKOWN PROPERTY TYPE";
  }

  def assembleTypeParams(typeParams) {
    if(!typeParams.isEmpty){
  		var ret = '';
  		for(param:typeParams){
  		  if(ret != '')
  		    ret += ',';
  		  ret += param.name;
  		}
  		return '[' + ret + ']';
    }
    else {
      return '';
    }
  }

  def fromObjectToInstanceOf(type, typeParams, methodTypeParams) {
    var ret = '';
    if(type.name == 'io.vertx.core.Future' && !type.isParameterized()) {
      if(typeParams.isEmpty && methodTypeParams.isEmpty)
        ret += '.asInstanceOf[JFuture[_]]';
      else
        ret += '.asInstanceOf[JFuture[T]]';
    }
    else {
      ret += '.asInstanceOf[' + toJavaType(type) + ']';
    }
    return ret;
  }

  def escapeIfKeyword(possibleKeyword) {
    if (isKeyword(possibleKeyword)) {
      return '`' + possibleKeyword + '`';
    }
    return possibleKeyword;
  }

  def isKeyword(possibleKeyword) {
    if (possibleKeyword.equals("type")) {
      return true;
    }
    if (possibleKeyword.equals("object")) {
      return true;
    }
    return false;
  }

  def isParentConcrete(superTypes) {
    for(stype : superTypes) {
      if(stype.raw.concrete) {
        return true;
      }
    }
    return false;
  }

}
