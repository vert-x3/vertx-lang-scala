@code{
  def toScalaType(type) {
    var nullable = type.isNullable;
    /*TODO: Bug, some types get returned as CLASS_OTHER instead of CLASS_VOID*/
    if (type.kind == CLASS_VOID || type.name == 'java.lang.Void' || type.name == 'void') {
      return 'Unit';
    } else if (type.kind == CLASS_OBJECT) {
      if(type.name.contains('Object')){
        return 'AnyRef'
      }
      else {
        return type.name;
      }
    } else if (type.kind == CLASS_THROWABLE) {
      return 'Throwable';
    } else if (type.kind.basic) {
      if (type.name == 'byte' || type.name == 'java.lang.Byte') {
        return 'Byte';
      } else if (type.name == 'short' || type.name == 'java.lang.Short') {
        return 'Short';
      } else if (type.name == 'int' || type.name == 'java.lang.Integer') {
        return 'Int';
      } else if (type.name == 'long' || type.name == 'java.lang.Long') {
        return 'Long';
      } else if (type.name == 'float' || type.name == 'java.lang.Float') {
        return 'Float';
      } else if (type.name == 'double' || type.name == 'java.lang.Double') {
        return 'Double';
      } else if (type.name == 'boolean' || type.name == 'java.lang.Boolean') {
        return 'Boolean';
      } else if (type.name == 'char' || type.name == 'java.lang.Character') {
        return 'Char';
      } else if (type.kind == CLASS_STRING) {
        return 'String';
      }
    } else if (type.kind == CLASS_DATA_OBJECT) {
      return type.simpleName;
    } else if (type.kind == CLASS_LIST){
        var ret = 'scala.collection.mutable.Buffer';
        if (!type.args.isEmpty)
          ret += '[' + toScalaType(type.args[0]) + ']';
        return ret;
    } else if (type.kind == CLASS_SET){
        var ret = 'Set';
        if (!type.args.isEmpty)
          ret += '[' + toScalaType(type.args[0]) + ']';
        return ret;
    } else if (type.kind == CLASS_MAP){
        var ret = 'Map';
        if (!type.args.isEmpty())
          ret = 'Map[' + toScalaType(type.args[0]) + ', ' + toScalaType(type.args[1]) + ']';
        return ret;
    } else if (type.kind == CLASS_HANDLER) {
      return "io.vertx.core.Handler[" + toScalaType(type.args[0]) +"]";
    } else if (type.kind == CLASS_FUNCTION) {
      var type1 = toScalaType(type.args[0]);
      var type2 = toScalaType(type.args[1]);

      var ret = "";
      if (type1.equals("Unit")) {
        ret = "() => "+type2;
      } else {
        ret = type1 + " => " + type2;
      }
      return ret;
    } else if (type.kind == CLASS_JSON_OBJECT ||
               type.kind == CLASS_JSON_ARRAY ||
               type.kind == CLASS_ENUM){
      return type.name
    } else if (type.kind == CLASS_ASYNC_RESULT) {
      var ret = 'io.vertx.core.AsyncResult';
      if(!type.args.isEmpty)
        ret += '[' + toScalaType(type.args[0]) + ']';
      else
        ret += '[_]';
      return ret;
    } else if (type.kind == CLASS_API) {
      var ret = helper.getNonGenericType(type.simpleName);
      if (type instanceof io.vertx.codegen.type.ParameterizedTypeInfo) {
        if(type.args.empty) {
          ret += '[_]';
        }
        else {
          ret += '[';
          var first = true;
          for (arg : type.args) {
            if (first) {
              first = false;
            } else {
              ret += ', ';
            }
            ret += toScalaType(arg);
          }
          ret += ']';
        }
      }
      else if(type.name.contains('io.vertx.core.Future')) {
        ret += '[_]';
      }
      return ret;
    }
    else {
      return 'WTF!!!!!!'+type.name+' '+type.kind;
    }
  }

  def assembleTypeParams(typeParams) {
    if(!typeParams.isEmpty){
  		var ret = '';
  		for(param:typeParams){
  		  if(ret != '')
  		    ret += ',';
  		  ret += param.name;
  		}
  		return '[' + ret + ']';
    }
    else {
      return '';
    }
  }
}
