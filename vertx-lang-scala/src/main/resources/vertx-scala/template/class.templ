@comment{"# Template for DataObject code generation"}

@comment{"# Defines a few helper functions"}
@includeNamed{'scala-doc.templ'}
@includeNamed{'scala-imports.templ'}
@includeNamed{'scala-types.templ'}
@includeNamed{'scala-methods.templ'}
@code{
  var className = helper.getSimpleName(type.name);
}
/*\n
 * Copyright 2014 Red Hat, Inc.\n
 *\n
 * Red Hat licenses this file to you under the Apache License, version 2.0\n
 * (the "License"); you may not use this file except in compliance with the\n
 * License.  You may obtain a copy of the License at:\n
 *\n
 * http://www.apache.org/licenses/LICENSE-2.0\n
 *\n
 * Unless required by applicable law or agreed to in writing, software\n
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n
 * License for the specific language governing permissions and limitations\n
 * under the License.\n
 */\n\n

package @{type.raw.translatePackageName("scala")}\n
\n
import io.vertx.lang.scala.HandlerOps._\n
import scala.reflect.runtime.universe._\n
import io.vertx.lang.scala.Converter._\n
@comment{"# Generate the imports"}
@foreach{importedType : generateImports(type, importedTypes, methods)}
import @{importedType}\n
@end{}
\n

@if{doc != null}
/**\n
@{renderDoc("  *", doc, renderDocLink)}
  */\n
@end{}
@if{concrete}
	class @{className}@{assembleTypeParams(typeParams, true)}(private val _asJava: Object)
@else{}
	trait @{className}@{assembleTypeParams(typeParams, false)}
@end{}

@code{
  var clazzes = new java.util.ArrayList();
  var fazzes = new java.util.ArrayList();
  for(superType : superTypes) {
    if(superType.raw.isConcrete())
      clazzes.add(superType);
    else
      fazzes.add(superType);
  }
}

@comment{"## Inheritance"}
@if{!superTypes.isEmpty}
	 \n    extends @foreach{superType : clazzes}@{toScalaType(superType, false);}@if{superType.raw.isConcrete()}(_asJava)@end{}@end{' \n    with '}
	 @if{!clazzes.isEmpty() && !fazzes.isEmpty()}with @end{}@foreach{superType : fazzes}@{toScalaType(superType, false);}@if{superType.raw.isConcrete()}(_asJava)@end{}@end{' \n    with '}
@else{type.isHandler}
	 \n    extends io.vertx.core.Handler[@{toScalaType(type.getHandlerArg, false);}]
@end{}
 {\n
\n

@if{concrete}
	@includeNamed{'class-body.templ'}
	\n
object @{className}{\n
  def apply@{assembleTypeParams(typeParams, true)}(asJava: J@{className}@{assembleTypeParamsAsObjects(typeParams)}) = new @{className}@{assembleTypeParams(typeParams, false)}(asJava)
  \n
	@foreach{method : staticMethods}
		@if{method.doc != null}@{methodDoc(method, '  ', false);}@end{}
		@if{shouldMethodReturnAFuture(method)}
		  def @{createNameForMethodReturningAFuture(method)}
			@{assembleTypeParams(method.typeParams, true)}(
			@foreach{param:removeLastParam(method.params)}
				@{escapeIfKeyword(param.name)}: @{toScalaType(param.type, false)}
			@end{','}):scala.concurrent.Future[@{toScalaType(typeOfReturnedFuture(method), false)}] = {\n
				@comment{'TODO: Why is there no nullable-info available in here??'}
		    val promiseAndHandler = handlerForAsyncResultWithConversion[@{toJavaType(typeOfReturnedFuture(method), true)}, @{toScalaType(typeOfReturnedFuture(method), false)}](x => @{toScalaWithConversion('x', typeOfReturnedFuture(method), typeParams, method.typeParams)})\n
		    @{invokeMethodAndUseProvidedHandler('J'+className, type, method, typeParams, 'promiseAndHandler._1')}\n
		    promiseAndHandler._2.future\n
		  }\n
			\n
		@else{}
		  def @{escapeIfKeyword(method.name)}
			@{assembleTypeParams(method.typeParams, true)}
			(
				@foreach{param:method.params}
					@{escapeIfKeyword(param.name)}: @{toScalaType(param.type, false)}
				@end{','}):@{toScalaType(method.returnType, false)} = {\n
		    @{invokeStaticMethod('J'+className, type, method)}\n
		  }\n
			\n
		@end{}
	@end{}
}\n
@else{}
	@includeNamed{'trait-body.templ'}
	\n
object @{className}{\n
  def apply@{assembleTypeParams(typeParams, true)}(asJava: J@{className}@{assembleTypeParamsAsObjects(typeParams)}):@{className}@{assembleTypeParams(typeParams, false)} = new @{className}Impl@{assembleTypeParams(typeParams, false)}(asJava)\n
    private class @{className}Impl@{assembleTypeParams(typeParams, true)}(private val _asJava: Object) extends @{className}@{assembleTypeParams(typeParams, false)} {\n\n
    @includeNamed{'class-body.templ'}
}\n
@end{}






