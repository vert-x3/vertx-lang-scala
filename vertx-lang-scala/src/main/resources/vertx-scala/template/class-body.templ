@code{
  var futureMethods = findFutureMethods(instanceMethods);
  var cacheReturnMethods = findCacheReturnMethods(instanceMethods);
  var fluentMethods = findFluentMethods(instanceMethods);
  var basicMethods = findBasicMethods(instanceMethods);
  var defaultMethods = findDefaultMethods(instanceMethods);
  var futureMethods = findFutureMethods(instanceMethods);
}
@if{superTypes.isEmpty || !isParentConcrete(superTypes)}  def asJava = _asJava\n@end{}
@code{var cached_counter = 0;}
@foreach{method : cacheReturnMethods}
  private var cached_@{cached_counter}:@{toScalaType(method.returnType, false)} = _\n
@code{cached_counter++}
@end{}
\n
//cached methods\n
@code{var cached_method_counter = 0}
@foreach{method : cacheReturnMethods}
  @if{isMethodNeedsOverride(type.name, method)}override @end{}
	def @{escapeIfKeyword(method.name)}
	@{assembleTypeParams(method.typeParams, true)}(
	@foreach{param:method.params}
		@{escapeIfKeyword(param.name)}: @{toScalaType(param.type, false)}
	@end{','}):@{toScalaType(method.returnType, false)} = {\n
    if(cached_@{cached_method_counter} == null) {\n
      var tmp = @{invokeMethodWithoutConvertingReturn('asJava' + fromObjectToInstanceOf(type), type, method, typeParams)}\n
      cached_@{cached_method_counter} = @{toScalaWithConversion('tmp', method.returnType, typeParams, method.typeParams)}\n
    }\n
    cached_@{cached_method_counter}\n
  }\n
	\n
	@code{cached_method_counter++}
@end{}

//fluent methods\n
@foreach{method : fluentMethods}
  @if{isMethodNeedsOverride(type.name, method)}override @end{}
	def @{escapeIfKeyword(method.name)}
	@{assembleTypeParams(method.typeParams, true)}(
	@foreach{param:method.params}
		@{escapeIfKeyword(param.name)}: @{toScalaType(param.type, false)}
	@end{','}):@{toScalaType(method.returnType, false)} = {\n
    @{invokeMethodWithoutConvertingReturn('asJava' + fromObjectToInstanceOf(type), type, method, typeParams)}\n
    this\n
  }\n
	\n
@end{}

//default methods\n
@foreach{method : defaultMethods}
  @foreach{ownerType : method.ownerTypes}//@{ownerType.name}\n@end{}
  @if{isMethodNeedsOverride(type.name, method)}override @end{}def @{escapeIfKeyword(method.name)}
	@{assembleTypeParams(method.typeParams, true)}(
	@foreach{param:method.params}
		@{escapeIfKeyword(param.name)}: @{toScalaType(param.type, false)}
	@end{','}):@{toScalaType(method.returnType, false)} = {\n
    @{invokeMethod('asJava' + fromObjectToInstanceOf(type), type, method, typeParams)}\n
  }\n
	\n
@end{}

//basic methods\n
@foreach{method : basicMethods}
  @if{isMethodNeedsOverride(type.name, method)}override @end{}
	def @{escapeIfKeyword(method.name)}
	@{assembleTypeParams(method.typeParams, true)}(
	@foreach{param:method.params}
		@{escapeIfKeyword(param.name)}: @{toScalaType(param.type, false)}
	@end{','}):@{toScalaType(method.returnType, false)} = {\n
    @{invokeMethod('asJava' + fromObjectToInstanceOf(type), type, method, typeParams)}\n
  }\n
	\n
@end{}

//future methods\n
@if{className != 'CompositeFuture' && className != 'Future' }
@foreach{method : futureMethods}
  def @{createNameForMethodReturningAFuture(method)}
	@{assembleTypeParams(method.typeParams, true)}(
	@foreach{param:removeLastParam(method.params)}
		@{escapeIfKeyword(param.name)}: @{toScalaType(param.type, false)}
	@end{','}):scala.concurrent.Future[@{toScalaType(typeOfReturnedFuture(method), false)}] = {\n
		@comment{'TODO: Why is there no nullable-info available in here??'}
    val promiseAndHandler = handlerForAsyncResultWithConversion[@{toJavaType(typeOfReturnedFuture(method), true)}, @{toScalaType(typeOfReturnedFuture(method), false)}](x => if (x == null) null.asInstanceOf[@{toScalaType(typeOfReturnedFuture(method), false)}] else @{toScalaWithConversion('x', typeOfReturnedFuture(method), typeParams, method.typeParams)})\n
    @{invokeMethodAndUseProvidedHandler('asJava' + fromObjectToInstanceOf(type), type, method, typeParams, 'promiseAndHandler._1')}\n
    promiseAndHandler._2.future\n
  }\n
	\n
@end{}
@end{}
}\n
