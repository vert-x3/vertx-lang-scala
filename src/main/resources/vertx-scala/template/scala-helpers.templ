@code{
  def toScalaType(type) {
    if (type.name == 'void' || type.name == 'java.lang.Void') {
      return 'Unit';
    } else if (type.kind == CLASS_STRING) {
      return 'String';
    } else if (type.kind == CLASS_PRIMITIVE || type.kind == CLASS_BOXED_PRIMITIVE) {
      if (type.name == 'byte' || type.name == 'java.lang.Byte') {
        return 'Byte';
      } else if (type.name == 'short' || type.name == 'java.lang.Short') {
        return 'Short';
      } else if (type.name == 'int' || type.name == 'java.lang.Integer') {
        return 'Int';
      } else if (type.name == 'long' || type.name == 'java.lang.Long') {
        return 'Long';
      } else if (type.name == 'float' || type.name == 'java.lang.Float') {
        return 'Float';
      } else if (type.name == 'double' || type.name == 'java.lang.Double') {
        return 'Double';
      } else if (type.name == 'boolean' || type.name == 'java.lang.Boolean') {
        return 'Boolean';
      } else if (type.name == 'char' || type.name == 'java.lang.Character') {
        return 'Char';
      }
    } else if (type.kind == CLASS_DATA_OBJECT || type.kind == CLASS_ENUM) {
      return type.name;
    } else if (isHandlerAsyncResult(type) || isHandlerFuture(type)) {
      return type.name.replace('<', '[').replace('>', ']');
    } else if (type.name.contains("io.vertx.core.json.JsonObject")){
      return type.name.replace('<', '[').replace('>', ']')
          .replace('java.lang.', '');
    } else {
      return type.name.replace("io.vertx.", "io.vertx.scala.")
          .replace('<', '[').replace('>', ']')
          .replace('java.lang.', '');
    }
  }

  def isHandlerFuture(type) {
    type.kind == CLASS_HANDLER && type.name.contains("io.vertx.core.Future");
  }

  def isHandlerAsyncResult(type) {
    type.kind == CLASS_HANDLER && type.args[0].kind == CLASS_ASYNC_RESULT;
  }

  def toJavaType(type) {
    type.name.replace('<', '[').replace('>', ']');
  }

  def getGenericType(name) {
    var start = name.indexOf("<");
    if (start >= 0) {
       var end = name.indexOf(">");
       return '[' + name.substring(start + 1, end) + ']';
    }
    return '';
  }

  def toScalaApply(name) {
    helper.getNonGenericType(name) + '.apply' + getGenericType(name);
  }

  def isFuture(method) {
    method.kind == METHOD_FUTURE;
  }

  def futureType(method) {
    toScalaType(method.params.get(method.params.size() - 1).type.args[0].args[0]);
  }

  def handlerType(method) {
    toScalaType(method.params.get(method.params.size() - 1).type.args[0]);
  }

  def handlerParamName(method) {
    method.params.get(method.params.size() - 1).name;
  }

  def isAsyncResult(param) {
    param.type.kind == CLASS_HANDLER && param.type.args[0].kind == CLASS_ASYNC_RESULT;
  }

  def isParamHandler(param) {
    return (param.type.kind == CLASS_HANDLER && param.type.args[0].kind != CLASS_ASYNC_RESULT) &&
      !param.type.name.contains("io.vertx.core.Future");
  }

  def isMethodHandler(method) {
    for (param : method.params) {
      if (isParamHandler(param)) {
        return true;
      }
    }
    return false;
  }

  def isParamHandlerConvert(param) {
    param.type.kind == CLASS_HANDLER && param.type.args[0].kind == CLASS_API && !param.type.name.contains("io.vertx.core.Future");
  }

  def importHandlerImplicits(method) {
    for (param : method.params) {
      if (isParamHandler(param)) {
        return true;
      }
    }
    return false;
  }

  def includeParam(param) {
    !isParamHandler(param);
  }

  def returnTypeOf(method) {
    if (isFuture(method)) {
      'Future[' + futureType(method) + ']';
    } else if (method.fluent) {
      toScalaType(type);
    } else if (method.returnType instanceof io.vertx.codegen.TypeInfo$Void) {
      'Unit';
    } else {
      toScalaType(method.returnType);
    }
  }

  def methodParams(method) {
    var paramList = '';
    var first = true;
    for (param : method.params) {
      if (includeParam(param)) {
        if (first) {
          first = false;
        } else {
          paramList += ', ';
        }

        if (param.name.equals("type")) {
          paramList += '`';
          paramList += param.name;
          paramList += '`'
        } else {
          paramList += param.name;
        }
        paramList += ': ';
        paramList += toScalaType(param.type);
      }
    }
    paramList;
  }

  def multiMethodParams(method) {
    params = methodParams(method);
    if (isMethodHandler(method)) {
      if (params.isEmpty()) {
        params = '';
      } else {
        params = '(' + params + ')';
      }
      params += '(' + handlerLambda(method) + ')';
      params;
    } else {
       '(' + params + ')';
    }
  }

  def methodInvocation(target, method, indentation) {
    var invocation = '';
    var first = true;
    var fluent = method.isFluent();
    var wrap = false;

    if (importHandlerImplicits(method)) {
      invocation += 'import io.vertx.lang.scala.HandlerOps._\n    ';
      invocation += indentation
    }

    if (!fluent and method.returnType.kind == CLASS_API) {
      wrap = true;
      invocation += toScalaApply(method.returnType.getSimpleName()) + '(';
    }

    invocation += target + '.' + method.name + '(';
    for (param : method.params) {
      if (first) {
        first = false;
      } else {
        invocation += ', ';
      }

      if (isParamHandlerConvert(param)) {
        invocation += 'funcToMappedHandler(' + toScalaApply(param.type.args[0].getSimpleName()) + ')(';
      }

      if (param.name.equals("type")) {
        invocation += '`';
        invocation += param.name;
        invocation += '`'
      } else {
        invocation += param.name;
      }

      if (param.type.kind == CLASS_API) {
        invocation += '.asJava.asInstanceOf[';
        invocation += toJavaType(param.type);
        invocation += ']';
      } else if (isParamHandlerConvert(param)) {
        invocation += ')';
      }
    }
    if (method.isFluent()) {
      invocation += '); this\n';
    } else if (wrap) {
      invocation += '))\n';
    } else {
      invocation += ')\n';
    }

    invocation;
  }

  def methodInvocationFuture(target, method) {
    var invocation = 'future[' + futureType(method) + ']';
    invocation += '(p => ' + target + '.' + method.name + '(';
    var first = true;
    for (param : method.params) {
      if (first) {
        first = false;
      } else {
        invocation += ', ';
      }

      if (isAsyncResult(param)) {
        invocation += 'p'
      } else {
        if (param.name.equals("type")) {
          invocation += '`' + param.name + '`';
        } else {
          invocation += param.name;
        }
      }
    }
    invocation += '))\n';
    invocation;
  }

  def handlerLambda(method) {
    type = handlerType(method);
    name = handlerParamName(method);
    if (type == "Unit") {
      name + ": => Unit";
    } else {
      name + ": " + type + " => Unit";
    }
  }
}