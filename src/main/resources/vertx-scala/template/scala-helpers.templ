@code{

  def toScalaType(type) {
    if (type.name == 'void' || type.name == 'java.lang.Void') {
      return 'Unit';
    } else if (type.name == 'Object' || type.name == 'java.lang.Object') {
      return 'AnyRef';
    } else if (type.name == 'Throwable' || type.name == 'java.lang.Throwable') {
      return 'Throwable';
    } else if (type.kind == CLASS_STRING) {
      return 'String';
    } else if (type.kind == CLASS_PRIMITIVE || type.kind == CLASS_BOXED_PRIMITIVE) {
      if (type.name == 'byte' || type.name == 'java.lang.Byte') {
        return 'Byte';
      } else if (type.name == 'short' || type.name == 'java.lang.Short') {
        return 'Short';
      } else if (type.name == 'int' || type.name == 'java.lang.Integer') {
        return 'Int';
      } else if (type.name == 'long' || type.name == 'java.lang.Long') {
        return 'Long';
      } else if (type.name == 'float' || type.name == 'java.lang.Float') {
        return 'Float';
      } else if (type.name == 'double' || type.name == 'java.lang.Double') {
        return 'Double';
      } else if (type.name == 'boolean' || type.name == 'java.lang.Boolean') {
        return 'Boolean';
      } else if (type.name == 'char' || type.name == 'java.lang.Character') {
        return 'Char';
      }
    } else if (type.kind == CLASS_DATA_OBJECT || type.kind == CLASS_ENUM) {
      return type.name;
    } else if (type.kind == CLASS_LIST){
        if(type.args.isEmpty)
          return 'List';
        else if(type.args[0].params.isEmpty())
          return 'List[' + toScalaType(type.args[0]) + ']';
        else
          return 'List[' + toScalaType(type.args[0]) + '[_]]';
    } else if (type.kind == CLASS_SET){
        if(type.args.isEmpty)
          return 'Set';
        else if(type.args[0].params.isEmpty())
          return 'Set[' + toScalaType(type.args[0]) + ']';
        else
          return 'Set[' + toScalaType(type.args[0]) + '[_]]';
    } else if (type.kind == CLASS_MAP){
        if(type.args.isEmpty)
          'Map';
        else if(type.args[0].params.isEmpty())
          'Map[' + toScalaType(type.args[0]) + ', ' + toScalaType(type.args[1]) + ']';
        else
          'Map[' + toScalaType(type.args[0]) + '[_], ' + toScalaType(type.args[1]) + '[_]]';
    } else if (type.kind == CLASS_HANDLER) {
      var type = toScalaType(type.args[0]);

      if (type.equals("Unit")) {
        return "() => Unit";
      } else {
        return type + " => Unit";
      }
    } else if (type.kind == CLASS_JSON_OBJECT ||
               type.kind == CLASS_JSON_ARRAY){
      return toJavaType(type)
    } else if (type.kind == CLASS_API) {
      var retVal = helper.getNonGenericType(type.translateName("scala"));
      if (type instanceof io.vertx.codegen.type.ParameterizedTypeInfo) {
        retVal += '[';
        var first = true;
        for (arg : type.args) {
          if (first) {
            first = false;
          } else {
            retVal += ', ';
          }
          retVal += toScalaType(arg);
        }
        retVal += ']';
      }
      return retVal;
    }
    else {
      return type.name.replace('<', '[').replace('>', ']');
    }
  }

  def isHandlerFuture(type) {
    type.kind == CLASS_HANDLER && type.name.contains("io.vertx.core.Future");
  }

  def toJavaType(type) {
    type.name.replace('<', '[').replace('>', ']');
  }

  def getGenericType(name) {
    var start = name.indexOf("<");
    if (start >= 0) {
       var end = name.indexOf(">");
       return '[' + name.substring(start + 1, end) + ']';
    }
    return '';
  }

  def toScalaApply(name) {
    helper.getNonGenericType(name) + '.apply' + getGenericType(name);
  }

  def toScalaApplyWithParam(name, paramName) {
    helper.getNonGenericType(name) + '.apply' + getGenericType(name) + '(' + paramName + ')';
  }

  def isFuture(method) {
    method.kind == METHOD_FUTURE;
  }

  def futureType(method) {
    toScalaType(method.params.get(method.params.size() - 1).type.args[0].args[0]);
  }

  def isAsyncResult(param) {
    param.type.kind == CLASS_HANDLER && param.type.args[0].kind == CLASS_ASYNC_RESULT;
  }

  def isParamHandler(param) {
    return (param.type.kind == CLASS_HANDLER && param.type.args[0].kind != CLASS_ASYNC_RESULT) &&
      !param.type.name.contains("io.vertx.core.Future");
  }

  def isMethodHandler(method) {
    for (param : method.params) {
      if (isParamHandler(param)) {
        return true;
      }
    }
    return false;
  }

  def importHandlerImplicits(method) {
    for (param : method.params) {
      if (isParamHandler(param)) {
        return true;
      }
    }
    return method.kind == METHOD_FUTURE;;
  }


  def importJavaConversions(method) {
    for (param : method.params) {
      if ((param.type.kind == CLASS_HANDLER &&
           param.type.args[0].kind.collection) ||
          (isAsyncResult(param) &&
           param.type.args[0].args[0].kind.collection) ||
          param.type.kind.collection) {
        return true;
      }
    }

    return method.returnType.kind.collection;
  }

  def returnTypeOf(method) {
    if (method.fluent) {
      toScalaType(method.returnType);
    } else if (method.returnType instanceof io.vertx.codegen.type.VoidTypeInfo) {
      'Unit';
    } else {
      toScalaType(method.returnType);
    }
  }

  def methodParams(method) {
    var paramList = '';
    var first = true;
    for (param : method.params) {
        if (first) {
          first = false;
        } else {
          paramList += ', ';
        }
        /* TODO: type is a scala keyword*/
        if (param.name.equals("type")) {
          paramList += '`' + param.name + '`';
        } else {
          paramList += param.name;
        }
        paramList += ': '+toScalaType(param.type);
    }
    paramList;
  }

  def multiMethodParams(method) {
    params = methodParams(method);
    if (params.isEmpty()) {
      params = '';
    } else {
      params = '(' + params + ')';
    }
  }

  def createGenericFromTypeWithParamName(type, paramName) {
    var invocation = '';
    if (type.kind == CLASS_API ||
        type.kind == CLASS_DATA_OBJECT ||
        type.kind == CLASS_ENUM) {
      invocation += toScalaApplyWithParam(type.getSimpleName(), paramName);
    } else if (type.kind == CLASS_PRIMITIVE ||
               type.kind == CLASS_BOXED_PRIMITIVE ||
               type.name == 'Throwable' ||
               type.name == 'java.lang.Throwable') {
      invocation += paramName + ':' + toScalaType(type);
    } else if (type.kind == CLASS_STRING ||
               type.kind == CLASS_JSON_OBJECT ||
               type.kind == CLASS_JSON_ARRAY) {
      invocation += paramName;
    }
    return invocation;
  }

  def methodInvocationHandlerCollection(type, method) {
    var invocation = '';
    var mapIt = method + '[' + toJavaType(type) + ', ' + toScalaType(type) + '](x => x.asScala';

    if(type.kind == CLASS_MAP) {
        invocation += mapIt + '.map((a) => (' + createGenericFromTypeWithParamName(type.args[0], 'a._1') + ',' + createGenericFromTypeWithParamName(type.args[1], 'a._2') + '))'
    }
    else {
      var listType = type.args[0];
      if (listType.kind == CLASS_API ||
          listType.kind == CLASS_DATA_OBJECT ||
          listType.kind == CLASS_ENUM) {
        invocation += mapIt + '.map(' + toScalaApply(listType.getSimpleName()) + ')';
      } else if (listType.kind == CLASS_PRIMITIVE || listType.kind == CLASS_BOXED_PRIMITIVE ||
                 listType.name == 'Throwable' || listType.name == 'java.lang.Throwable') {
        invocation += mapIt + '.map(x => x:' + toScalaType(listType) + ')';
      } else if (listType.kind == CLASS_STRING ||
                 listType.kind == CLASS_JSON_OBJECT ||
                 listType.kind == CLASS_JSON_ARRAY) {
        invocation += mapIt
      }
    }

    if (type.kind == CLASS_LIST) {
      invocation += '.toList)('+param.name;
    } else if (type.kind == CLASS_SET) {
      invocation += '.toSet)('+param.name;
    } else {
      invocation += '.toMap)('+param.name;
    }

    return invocation;
  }

  def methodInvocationHandler(type, mappedFunc, func, convertUnit, param) {
    var invocation = '';

    if (type.kind == CLASS_API) {
      invocation += mappedFunc + '(' + toScalaApply(type.getSimpleName()) + ')('+param.name;
    } else if (type.kind == CLASS_LIST ||
               type.kind == CLASS_SET ||
               type.kind == CLASS_MAP) {
      invocation += methodInvocationHandlerCollection(type, mappedFunc);
    } else if (type.kind == CLASS_PRIMITIVE || type.kind == CLASS_BOXED_PRIMITIVE ||
               type.name == 'Throwable' || type.name == 'java.lang.Throwable') {
      invocation += mappedFunc + '[' + toJavaType(type) + ', ' + toScalaType(type) + '](x => x)('+param.name;
    } else if (type.kind == CLASS_STRING ||
               type.kind == CLASS_JSON_OBJECT ||
               type.kind == CLASS_JSON_ARRAY) {
      invocation += func + '[' + toJavaType(type) + '](' + param.name;
    } else if (type.name == 'void' || type.name == 'java.lang.Void') {
      invocation += mappedFunc + '[' + toJavaType(type) + ', ' + toScalaType(type) + '](x => x.asInstanceOf[Unit])('+ param.name;
      if (convertUnit) {
        invocation += '_ => ';
      }
      if(param.type.args[0].kind == CLASS_VOID) {
         invocation += param.name + '()';
      }
      else {
         invocation += param.name + '(_)';
      }
    } else {
      invocation += func + '(' + param.name;
    }

    return invocation;
  }

  def methodInvocation(target, method, indentation) {
    var invocation = indentation;
    var first = true;
    var fluent = method.isFluent();
    var wrap = false;

    if (importJavaConversions(method)) {
      invocation += 'import scala.collection.JavaConverters._\n';
      invocation += indentation;
    }

    /** TODO: UGLYYY } **/
    if (method.returnType.kind == CLASS_HANDLER) {
      var ret = method.returnType.args[0];
      var scalaType = toScalaType(method.returnType.args[0]);
      invocation += indentation;
      if (ret.kind == CLASS_API ||
          ret.kind == CLASS_DATA_OBJECT ||
          ret.kind == CLASS_ENUM) {
          /* TODO: x.asScala doesn't work for everything*/
        invocation += 'handlerToMappedFunction[' + toJavaType(ret) + ', ' + scalaType +'](x => x.asJava)(';
      } else if (ret.kind == CLASS_PRIMITIVE ||
                 ret.kind == CLASS_BOXED_PRIMITIVE ||
                 ret.name == 'Throwable' ||
                 ret.name == 'java.lang.Throwable') {
        invocation += 'handlerToFunc[' + scalaType +'](';
      } else if (ret.kind == CLASS_STRING ||
                 ret.kind == CLASS_JSON_OBJECT ||
                 ret.kind == CLASS_JSON_ARRAY) {
        invocation += 'handlerToFunc[' + scalaType +'](';
      } else {
        invocation += 'handlerToFunc[' + scalaType +'](';
      }
    }

    if (!fluent and method.returnType.kind == CLASS_API) {
      wrap = true;
      invocation += toScalaApply(method.returnType.getSimpleName()) + '(';
    }

    invocation += target + '.' + method.name + '(';
    for (param : method.params) {
      if (first) {
        first = false;
      } else {
        invocation += ', ';
      }

      /* TODO: type is a keyword in scala */
      if (param.name.equals("type")) {
        invocation += '`';
        invocation += param.name;
        invocation += '`'
      } else {
        if (param.type.kind == CLASS_LIST ||
            param.type.kind == CLASS_SET) {
          if (param.type.args[0].kind == CLASS_API) {
            invocation += param.name + '.map(x => x.asJava).asJava';
          } else {
            invocation += param.name + '.map(x => x:' + param.type.args[0].name + ').asJava';
          }
        } else if (param.type.kind == CLASS_MAP) {
          if (param.type.args[0].kind == CLASS_API &&
              param.type.args[1].kind == CLASS_API)
          {
            invocation += param.name + '.map(kv => (kv._1.asJava.asInstanceOf[' + toJavaType(param.type.args[0]) + '], kv._2.asJava.asInstanceOf[' + toJavaType(param.type.args[1]) + '])).asJava';
          } else if (param.type.args[0].kind == CLASS_API) {
            invocation += param.name + '.map(kv => (kv._1.asJava.asInstanceOf[' + toJavaType(param.type.args[0]) + '], kv._2:' + param.type.args[1].name + ')).asJava';
          } else if (param.type.args[1].kind == CLASS_API) {
            invocation += param.name + '.map(kv => (kv._1:' + param.type.args[0].name + ', kv._2.asJava.asInstanceOf[' + toJavaType(param.type.args[1]) + '])).asJava';
          } else {
            invocation += param.name + '.map(kv => (kv._1:' + param.type.args[0].name + ', kv._2:' + param.type.args[1].name + ')).asJava';
          }
        } else if (param.type.kind == CLASS_HANDLER) {
            var handlerType = param.type.args[0];
            invocation += methodInvocationHandler(handlerType, 'funcToMappedHandler', 'funcToHandler', true, param);
            invocation += ')';
        }
        else {
          invocation += param.name;
        }
      }

      if (param.type.kind == CLASS_API) {
        invocation += '.asJava.asInstanceOf[' + toJavaType(param.type) +']'
      }
    }
    if (wrap) {
      invocation += '))';
    } else {
      invocation += ')';
    }

    if (method.returnType.kind == CLASS_LIST) {
      if (method.returnType.args[0].kind == CLASS_API) {
        invocation += '.asScala.map(' + toScalaApply(method.returnType.args[0].getSimpleName()) + ').toList';
      } else {
        invocation += '.asScala.map(x => x:' + toScalaType(method.returnType.args[0]) + ').toList';
      }
    } else if (method.returnType.kind == CLASS_SET) {
      if (method.returnType.args[0].kind == CLASS_API) {
        invocation += '.asScala.map(' + toScalaApply(method.returnType.args[0].getSimpleName()) + ').toSet';
      } else {
        invocation += '.asScala.map(x => x:' + toScalaType(method.returnType.args[0]) + ').toSet';
      }
    } else if (method.returnType.kind == CLASS_MAP) {
      if (method.returnType.args[1].kind == CLASS_API) {
        invocation += '.asScala.map(kv => (kv._1, kv._2: ' + toScalaApply(method.returnType.args[1].getSimpleName()) + ')).toMap';
      } else if (method.returnType.args[1].kind == CLASS_STRING ||
                 method.returnType.args[1].kind == CLASS_JSON_OBJECT ||
                 method.returnType.args[1].kind == CLASS_JSON_ARRAY) {
        invocation += '.asScala.toMap';
      } else {
        invocation += '.asScala.map     (kv => (kv._1, kv._2: ' + toScalaType(method.returnType.args[1]) + ')).toMap';
      }
    } else if (method.returnType.kind == CLASS_HANDLER) {
      invocation += ')'
    }

    invocation += '\n';
    if (method.isFluent()) {
      invocation += indentation;
      invocation += 'this\n';
    }
    invocation;
  }

  def includeMethod(method, instanceMethods) {
    if(method.name == 'addInterceptor') {
        return false
    }
    if(method.name == 'removeInterceptor') {
        return false
    }
    return true;
  }
}