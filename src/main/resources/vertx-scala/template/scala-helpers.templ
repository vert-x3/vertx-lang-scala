@code{
  def toScalaType(type) {
    if (type.name == 'void' || type.name == 'java.lang.Void') {
      return 'Unit';
    } else if (type.kind == CLASS_STRING) {
      return 'String';
    } else if (type.kind == CLASS_PRIMITIVE || type.kind == CLASS_BOXED_PRIMITIVE) {
      if (type.name == 'byte' || type.name == 'java.lang.Byte') {
        return 'Byte';
      } else if (type.name == 'short' || type.name == 'java.lang.Short') {
        return 'Short';
      } else if (type.name == 'int' || type.name == 'java.lang.Integer') {
        return 'Int';
      } else if (type.name == 'long' || type.name == 'java.lang.Long') {
        return 'Long';
      } else if (type.name == 'float' || type.name == 'java.lang.Float') {
        return 'Float';
      } else if (type.name == 'double' || type.name == 'java.lang.Double') {
        return 'Double';
      } else if (type.name == 'boolean' || type.name == 'java.lang.Boolean') {
        return 'Boolean';
      } else if (type.name == 'char' || type.name == 'java.lang.Character') {
        return 'Char';
      }
    } else if (type.name == 'io.vertx.core.eventbus.DeliveryOptions') {
      return type.name;
    } else if (type.kind == CLASS_HANDLER && param.type.args[0].kind == CLASS_ASYNC_RESULT) {
      return type.name.replace('<', '[').replace('>', ']');
    } else {
      return type.name.replace("io.vertx.", "io.vertx.scala.").replace('<', '[').replace('>', ']');
    }
  }

  def toJavaType(type) {
    type.name.replace('<', '[').replace('>', ']');
  }

  def isFuture(method) {
    method.kind == METHOD_FUTURE;
  }

  def futureType(method) {
    toScalaType(method.params.get(method.params.size() - 1).type.args[0].args[0]);
  }

  def handlerType(method) {
    toScalaType(method.params.get(method.params.size() - 1).type.args[0]);
  }

  def handlerParamName(method) {
    method.params.get(method.params.size() - 1).name;
  }

  def isAsyncResult(param) {
    param.type.kind == CLASS_HANDLER && param.type.args[0].kind == CLASS_ASYNC_RESULT;
  }

  def isHandler(param) {
    param.type.kind == CLASS_HANDLER && param.type.args[0].kind != CLASS_ASYNC_RESULT;
  }

  def needsHandlerConversion(param) {
    param.type.kind == CLASS_HANDLER && param.type.args[0].kind == CLASS_API;
  }

  def includeParam(param) {
    !isHandler(param);
  }

  def returnTypeOf(method) {
    if (isFuture(method)) {
      'Future[' + futureType(method) + ']';
    } else if (method.fluent) {
      toScalaType(type);
    } else if (method.returnType instanceof io.vertx.codegen.TypeInfo$Void) {
      'Unit';
    } else {
      toScalaType(method.returnType);
    }
  }

  def methodParams(method) {
    var paramList = '';
    var first = true;
    for (param : method.params) {
      if (includeParam(param)) {
        if (first) {
          first = false;
        } else {
          paramList += ', ';
        }

        if (param.name.equals("type")) {
          paramList += '`';
          paramList += param.name;
          paramList += '`'
        } else {
          paramList += param.name;
        }
        paramList += ': ';
        paramList += toScalaType(param.type);
      }
    }
    paramList;
  }

  def multiMethodParams(method) {
    params = methodParams(method);
    if (method.kind == METHOD_HANDLER) {
      if (params.isEmpty()) {
        params = '';
      } else {
        params = '(' + params + ')';
      }
      params += '(' + handlerLambda(method) + ')';
      params;
    } else {
       '(' + params + ')';
    }
  }

  def methodInvocation(target, method) {
    var invocation = '';
    var first = true;
    var fluent = method.isFluent();
    var wrap = false;

    if (method.kind == METHOD_HANDLER) {
      invocation += 'import io.vertx.lang.scala.HandlerOps._\n    ';
    }

    if (!fluent and method.returnType.kind == CLASS_API) {
      wrap = true;
      invocation += method.returnType.getSimpleName() + '.apply(';
    }

    invocation += target + '.' + method.name + '(';
    for (param : method.params) {
      if (first) {
        first = false;
      } else {
        invocation += ', ';
      }

      if (needsHandlerConversion(param)) {
        invocation += 'funcToMappedHandler(' + param.type.args[0].getSimpleName() + '.apply)(';
      }

      if (param.name.equals("type")) {
        invocation += '`';
        invocation += param.name;
        invocation += '`'
      } else {
        invocation += param.name;
      }

      if (param.type.kind == CLASS_API) {
        invocation += '.asJava';
      } else if (needsHandlerConversion(param)) {
        invocation += ')';
      }
    }
    if (method.isFluent()) {
      invocation += '); this\n';
    } else if (wrap) {
      invocation += '))\n';
    } else {
      invocation += ')\n';
    }

    invocation;
  }

  def methodInvocationFuture(target, method) {
    var invocation = 'future[' + futureType(method) + ']';
    invocation += '(p => ' + target + '.' + method.name + '(';
    var first = true;
    for (param : method.params) {
      if (first) {
        first = false;
      } else {
        invocation += ', ';
      }

      if (isAsyncResult(param)) {
        invocation += 'p'
      } else {
        if (param.name.equals("type")) {
          invocation += '`' + param.name + '`';
        } else {
          invocation += param.name;
        }
      }
    }
    invocation += '))\n';
    invocation;
  }

  def handlerLambda(method) {
    type = handlerType(method);
    name = handlerParamName(method);
    if (type == "Unit") {
      name + ": => Unit";
    } else {
      name + ": " + type + " => Unit";
    }
  }
}